웹브라우저 동작원리

js 실행 엔진 - 웹브라우저
stack : 코드 실행해주는 곳. 근데 하나라서 한번에 하나밖에 실행할 수 없다. 
single threaded

처리가 오래 걸리는 코드는 대기실로 제껴놓는다.  
대기실 보내는 코드들이 정해져 있음.
Ajax요청코드, 이벤트레스너, setTimeout등등
처리가 완료 되면, 
Queue라는 곳에 처리가 완료된 코드들을 줄을 세워놓는다. 
그리고 차례대로 stack에 다시 올려준다.
단, stack이 비어있을 때만.

예시로 setTimeout이 0초일땐? 그래도 무조껀 뒤에 실행됨. 대기실로 보냄.

ex) 반복문을 엄청 많이 씀. 천만번 돌림 ->  10초 걸리는 어려운 연산을 하는 동안 Ajax요청코드, 이벤트레스너, setTimeout 같은 작업이 다 안 돌아감. stack이 비어있지 않아서 올려주지 못하기 때문임. 브라우저 프리징의 원인

1. stack 을 바쁘게 만들면 안된다.
2. queue를 바쁘게 하면 안된다. 버벅임의 원인이 됨. 
ex) 모달창 띄워주세요 x10000 이런거 

자바스크립트는 동기적으로 처리된다. 한번에 한줄 순서대로 처리됨. 
가끔 비동기적인 처리도 가능하다. (jax요청코드, 이벤트레스너, setTimeout) 이런 함수들을 쓸 때. 


◆ 그래도 이런 작업을 해야 한다면?

1. setTimeout을 이용한다.

setTimeout()을 이용해서 0초마다 0~1억 반복, 1억~2억 반복, 2억~3억 반복... 
0초마다 Queue로 보내기 때문에 그 사이사이에 사용자의 이벤트리스너 이런 코드를 실행가능하다.
(setTimeout 타이머를 0초로 설정해도 실은 4ms로 동작함. 설정가능한 최소시간이 4ms 임)

2. Web worker를 이용한다.
Worker라는 클래스를 사용
다른 자바스크립트 파일을 이용해서 그 파일에서 힘든 연산을 시키고 그게 완료가 되면 값을 가져오라고 명령

//------------------------------------------------
(메인 js 파일)
var myWorker = new Worker('worker.js'); 

w.onmessage = function(e){
  console.log(e.data) //이러면 1 나올듯
};
//------------------------------------------------
(worker.js 파일)

var i = 0;
postMessage(i + 1); //postMessage라는 특별한 함수가 있음
//------------------------------------------------

worker.js에서 작업이 완료될 시 postMessage() 이렇게 실행하면
다른 파일로 완료된 결과값을 전달해줄 수 있다.
이러면 Stack이 바빠지지 않는다.